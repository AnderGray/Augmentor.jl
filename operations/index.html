<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Supported Operations · Augmentor.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/><link href="../assets/favicon.ico" rel="shortcut icon" type="image/x-icon"/><link href="../assets/style.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../index.html"><img class="logo" src="../assets/logo.png" alt="Augmentor.jl logo"/></a><h1>Augmentor.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li><a class="toctext" href="../gettingstarted/">Getting Started</a></li><li><a class="toctext" href="../background/">Background and Motivation</a></li><li><a class="toctext" href="../images/">Working with Images in Julia</a></li><li class="current"><a class="toctext" href>Supported Operations</a><ul class="internal"><li><a class="toctext" href="#Mirroring-1">Mirroring</a></li><li><a class="toctext" href="#Rotating-1">Rotating</a></li><li><a class="toctext" href="#Shearing-1">Shearing</a></li><li><a class="toctext" href="#Scaling-1">Scaling</a></li><li><a class="toctext" href="#Resizing-1">Resizing</a></li><li><a class="toctext" href="#Distorting-1">Distorting</a></li><li><a class="toctext" href="#Cropping-1">Cropping</a></li><li><a class="toctext" href="#Conversion-1">Conversion</a></li><li><a class="toctext" href="#Color-Channels-1">Color Channels</a></li><li><a class="toctext" href="#Array-Shape-1">Array Shape</a></li><li><a class="toctext" href="#Utility-Operations-1">Utility Operations</a></li></ul></li><li><a class="toctext" href="../generated/testexample/">Test Tutorial</a></li><li><a class="toctext" href="../LICENSE/">LICENSE</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Supported Operations</a></li></ul><a class="edit-page" href="https://github.com/Evizero/Augmentor.jl/tree/e49f28df1fb7d0da084ba0aaade9ffe70aa1742b/docs/src/operations.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Supported Operations</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Supported-Operations-1" href="#Supported-Operations-1">Supported Operations</a></h1><p>This page lists and describes all supported image operations in great detail. The operations are organized based on their categories and subcategories.</p><p>A sizeable amount of the provided operations fall under the category of <strong>affine transformations</strong>. As such, they can be described using what is known as an <a href="https://en.wikipedia.org/wiki/Affine_transformation">affine map</a>, which are inherently compose-able if chained together. However, utilizing such a affine formulation requires (costly) interpolation, which may not always be needed to achieve the desired effect. For that reason do some of the operations below also provide a special purpose implementation to produce their specified result. Those are usually preferred over the affine formulation if sensible considering the complete pipeline.</p><table><tr><th>Category</th><th>Available Operations</th></tr><tr><td>Mirroring</td><td><a href="#Augmentor.FlipX"><code>FlipX</code></a>, <a href="#Augmentor.FlipY"><code>FlipY</code></a></td></tr><tr><td>Rotating</td><td><a href="#Augmentor.Rotate90"><code>Rotate90</code></a>, <a href="#Augmentor.Rotate270"><code>Rotate270</code></a>, <a href="#Augmentor.Rotate180"><code>Rotate180</code></a>, <a href="#Augmentor.Rotate"><code>Rotate</code></a></td></tr><tr><td>Shearing</td><td><a href="#Augmentor.ShearX"><code>ShearX</code></a>, <a href="#Augmentor.ShearY"><code>ShearY</code></a></td></tr><tr><td>Scaling</td><td><a href="#Augmentor.Scale"><code>Scale</code></a>, <a href="#Augmentor.Zoom"><code>Zoom</code></a>, <a href="#Augmentor.Resize"><code>Resize</code></a></td></tr></table><p>Aside from affine transformations, Augmentor also provides functionality for performing a variety of distortions. These types of operations usually provide a much larger distribution of possible output images.</p><table><tr><th>Category</th><th>Available Operations</th></tr><tr><td>Distorting</td><td><a href="#Augmentor.ElasticDistortion"><code>ElasticDistortion</code></a></td></tr></table><p>The input images from a given dataset can be of various shapes and sizes. Yet, it is often required by the algorithm that the data must be of uniform structure. To that end Augmentor provides a number of ways to alter or subset given images.</p><table><tr><th>Category</th><th>Available Operations</th></tr><tr><td>Cropping</td><td><a href="#Augmentor.Crop"><code>Crop</code></a>, <a href="#Augmentor.CropNative"><code>CropNative</code></a>, <a href="#Augmentor.CropSize"><code>CropSize</code></a>, <a href="#Augmentor.CropRatio"><code>CropRatio</code></a>, <a href="#Augmentor.RCropRatio"><code>RCropRatio</code></a></td></tr><tr><td>Resizing</td><td><a href="#Augmentor.Resize"><code>Resize</code></a></td></tr></table><p>It is not uncommon that machine learning frameworks require the data in a specific form and layout. For example many deep learning frameworks expect the colorchannel of the images to be encoded in the third dimension of a 4-dimensional array. Augmentor allows to convert from (and to) these different layouts using special operations that are mainly useful in the beginning or end of a augmentation pipeline.</p><table><tr><th>Category</th><th>Available Operations</th></tr><tr><td>Conversion</td><td><a href="#Augmentor.ConvertEltype"><code>ConvertEltype</code></a></td></tr><tr><td>Information Layout</td><td><a href="#Augmentor.SplitChannels"><code>SplitChannels</code></a>, <a href="#Augmentor.CombineChannels"><code>CombineChannels</code></a>, <a href="#Augmentor.PermuteDims"><code>PermuteDims</code></a>, <a href="#Augmentor.Reshape"><code>Reshape</code></a></td></tr></table><p>Aside from &quot;true&quot; operations that specify some kind of transformation, there are also a couple of special utility operations used for functionality such as stochastic branching.</p><table><tr><th>Category</th><th>Available Operations</th></tr><tr><td>Utility Operations</td><td><a href="#Augmentor.NoOp"><code>NoOp</code></a>, <a href="#Augmentor.CacheImage"><code>CacheImage</code></a>, <a href="#Augmentor.Either"><code>Either</code></a></td></tr></table><h2><a class="nav-anchor" id="Mirroring-1" href="#Mirroring-1">Mirroring</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Augmentor.FlipX" href="#Augmentor.FlipX"><code>Augmentor.FlipX</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">FlipX &lt;: Augmentor.AffineOperation</code></pre><p><strong>Description</strong></p><p>Reverses the x-order of each pixel row. Another way of describing it would be to mirror the image on the y-axis, or to mirror the image horizontally.</p><p>If created using the parameter <code>p</code>, the operation will be lifted into <code>Either(p=&gt;FlipX(), 1-p=&gt;NoOp())</code>, where <code>p</code> denotes the probability of applying <code>FlipX</code> and <code>1-p</code> the probability for applying <a href="#Augmentor.NoOp"><code>NoOp</code></a>. See the documentation of <a href="#Augmentor.Either"><code>Either</code></a> for more information.</p><p><strong>Usage</strong></p><pre><code class="language-none">FlipX()

FlipX(p)</code></pre><p><strong>Arguments</strong></p><ul><li><p><strong><code>p::Number</code></strong> : Optional. Probability of applying the   operation. Must be in the interval [0,1].</p></li></ul><p><strong>See also</strong></p><p><a href="#Augmentor.FlipY"><code>FlipY</code></a>, <a href="#Augmentor.Either"><code>Either</code></a>, <a href="@ref"><code>augment</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Augmentor

julia&gt; img = [200 150; 50 1]
2×2 Array{Int64,2}:
 200  150
  50    1

julia&gt; img_new = augment(img, FlipX())
2×2 Array{Int64,2}:
 150  200
   1   50</code></pre></div><a class="source-link" target="_blank" href="https://github.com/Evizero/Augmentor.jl/tree/e49f28df1fb7d0da084ba0aaade9ffe70aa1742b/src/operations/flip.jl#L3-L53">source</a></section><div><table><tr><th>Input</th><th>Output for <code>FlipX()</code></th></tr><tr><td><img src="../assets/testpattern.png" alt="input"/></td><td><img src="../assets/FlipX.png" alt="output"/></td></tr></table></div><hr/><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Augmentor.FlipY" href="#Augmentor.FlipY"><code>Augmentor.FlipY</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">FlipY &lt;: Augmentor.AffineOperation</code></pre><p><strong>Description</strong></p><p>Reverses the y-order of each pixel column. Another way of describing it would be to mirror the image on the x-axis, or to mirror the image vertically.</p><p>If created using the parameter <code>p</code>, the operation will be lifted into <code>Either(p=&gt;FlipY(), 1-p=&gt;NoOp())</code>, where <code>p</code> denotes the probability of applying <code>FlipY</code> and <code>1-p</code> the probability for applying <a href="#Augmentor.NoOp"><code>NoOp</code></a>. See the documentation of <a href="#Augmentor.Either"><code>Either</code></a> for more information.</p><p><strong>Usage</strong></p><pre><code class="language-none">FlipY()

FlipY(p)</code></pre><p><strong>Arguments</strong></p><ul><li><p><strong><code>p::Number</code></strong> : Optional. Probability of applying the   operation. Must be in the interval [0,1].</p></li></ul><p><strong>See also</strong></p><p><a href="#Augmentor.FlipX"><code>FlipX</code></a>, <a href="#Augmentor.Either"><code>Either</code></a>, <a href="@ref"><code>augment</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Augmentor

julia&gt; img = [200 150; 50 1]
2×2 Array{Int64,2}:
 200  150
  50    1

julia&gt; img_new = augment(img, FlipY())
2×2 Array{Int64,2}:
  50    1
 200  150</code></pre></div><a class="source-link" target="_blank" href="https://github.com/Evizero/Augmentor.jl/tree/e49f28df1fb7d0da084ba0aaade9ffe70aa1742b/src/operations/flip.jl#L85-L135">source</a></section><div><table><tr><th>Input</th><th>Output for <code>FlipY()</code></th></tr><tr><td><img src="../assets/testpattern.png" alt="input"/></td><td><img src="../assets/FlipY.png" alt="output"/></td></tr></table></div><h2><a class="nav-anchor" id="Rotating-1" href="#Rotating-1">Rotating</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Augmentor.Rotate90" href="#Augmentor.Rotate90"><code>Augmentor.Rotate90</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">Rotate90 &lt;: Augmentor.AffineOperation</code></pre><p><strong>Description</strong></p><p>Rotates the image upwards 90 degrees. This is a special case rotation because it can be performed very efficiently by simply rearranging the existing pixels. However, it is generally not the case that the output image will have the same size as the input image, which is something to be aware of.</p><p>If created using the parameter <code>p</code>, the operation will be lifted into <code>Either(p=&gt;Rotate90(), 1-p=&gt;NoOp())</code>, where <code>p</code> denotes the probability of applying <code>Rotate90</code> and <code>1-p</code> the probability for applying <a href="#Augmentor.NoOp"><code>NoOp</code></a>. See the documentation of <a href="#Augmentor.Either"><code>Either</code></a> for more information.</p><p><strong>Usage</strong></p><pre><code class="language-none">Rotate90()

Rotate90(p)</code></pre><p><strong>Arguments</strong></p><ul><li><p><strong><code>p::Number</code></strong> : Optional. Probability of applying the   operation. Must be in the interval [0,1].</p></li></ul><p><strong>See also</strong></p><p><a href="#Augmentor.Rotate180"><code>Rotate180</code></a>, <a href="#Augmentor.Rotate270"><code>Rotate270</code></a>, <a href="#Augmentor.Rotate"><code>Rotate</code></a>, <a href="#Augmentor.Either"><code>Either</code></a>, <a href="@ref"><code>augment</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Augmentor

julia&gt; img = [200 150; 50 1]
2×2 Array{Int64,2}:
 200  150
  50    1

julia&gt; img_new = augment(img, Rotate90())
2×2 Array{Int64,2}:
 150   1
 200  50</code></pre></div><a class="source-link" target="_blank" href="https://github.com/Evizero/Augmentor.jl/tree/e49f28df1fb7d0da084ba0aaade9ffe70aa1742b/src/operations/rotation.jl#L3-L56">source</a></section><div><table><tr><th>Input</th><th>Output for <code>Rotate90()</code></th></tr><tr><td><img src="../assets/testpattern.png" alt="input"/></td><td><img src="../assets/Rotate90.png" alt="output"/></td></tr></table></div><hr/><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Augmentor.Rotate180" href="#Augmentor.Rotate180"><code>Augmentor.Rotate180</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">Rotate180 &lt;: Augmentor.AffineOperation</code></pre><p><strong>Description</strong></p><p>Rotates the image 180 degrees. This is a special case rotation because it can be performed very efficiently by simply rearranging the existing pixels. Furthermore, the output image will have the same dimensions as the input image.</p><p>If created using the parameter <code>p</code>, the operation will be lifted into <code>Either(p=&gt;Rotate180(), 1-p=&gt;NoOp())</code>, where <code>p</code> denotes the probability of applying <code>Rotate180</code> and <code>1-p</code> the probability for applying <a href="#Augmentor.NoOp"><code>NoOp</code></a>. See the documentation of <a href="#Augmentor.Either"><code>Either</code></a> for more information.</p><p><strong>Usage</strong></p><pre><code class="language-none">Rotate180()

Rotate180(p)</code></pre><p><strong>Arguments</strong></p><ul><li><p><strong><code>p::Number</code></strong> : Optional. Probability of applying the   operation. Must be in the interval [0,1].</p></li></ul><p><strong>See also</strong></p><p><a href="#Augmentor.Rotate90"><code>Rotate90</code></a>, <a href="#Augmentor.Rotate270"><code>Rotate270</code></a>, <a href="#Augmentor.Rotate"><code>Rotate</code></a>, <a href="#Augmentor.Either"><code>Either</code></a>, <a href="@ref"><code>augment</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Augmentor

julia&gt; img = [200 150; 50 1]
2×2 Array{Int64,2}:
 200  150
  50    1

julia&gt; img_new = augment(img, Rotate180())
2×2 Array{Int64,2}:
   1   50
 150  200</code></pre></div><a class="source-link" target="_blank" href="https://github.com/Evizero/Augmentor.jl/tree/e49f28df1fb7d0da084ba0aaade9ffe70aa1742b/src/operations/rotation.jl#L87-L139">source</a></section><div><table><tr><th>Input</th><th>Output for <code>Rotate180()</code></th></tr><tr><td><img src="../assets/testpattern.png" alt="input"/></td><td><img src="../assets/Rotate180.png" alt="output"/></td></tr></table></div><hr/><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Augmentor.Rotate270" href="#Augmentor.Rotate270"><code>Augmentor.Rotate270</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">Rotate270 &lt;: Augmentor.AffineOperation</code></pre><p><strong>Description</strong></p><p>Rotates the image upwards 270 degrees, which can also be described as rotating the image downwards 90 degrees. This is a special case rotation, because it can be performed very efficiently by simply rearranging the existing pixels. However, it is generally not the case that the output image will have the same size as the input image, which is something to be aware of.</p><p>If created using the parameter <code>p</code>, the operation will be lifted into <code>Either(p=&gt;Rotate270(), 1-p=&gt;NoOp())</code>, where <code>p</code> denotes the probability of applying <code>Rotate270</code> and <code>1-p</code> the probability for applying <a href="#Augmentor.NoOp"><code>NoOp</code></a>. See the documentation of <a href="#Augmentor.Either"><code>Either</code></a> for more information.</p><p><strong>Usage</strong></p><pre><code class="language-none">Rotate270()

Rotate270(p)</code></pre><p><strong>Arguments</strong></p><ul><li><p><strong><code>p::Number</code></strong> : Optional. Probability of applying the   operation. Must be in the interval [0,1].</p></li></ul><p><strong>See also</strong></p><p><a href="#Augmentor.Rotate90"><code>Rotate90</code></a>, <a href="#Augmentor.Rotate180"><code>Rotate180</code></a>, <a href="#Augmentor.Rotate"><code>Rotate</code></a>, <a href="#Augmentor.Either"><code>Either</code></a>, <a href="@ref"><code>augment</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Augmentor

julia&gt; img = [200 150; 50 1]
2×2 Array{Int64,2}:
 200  150
  50    1

julia&gt; img_new = augment(img, Rotate270())
2×2 Array{Int64,2}:
 50  200
  1  150</code></pre></div><a class="source-link" target="_blank" href="https://github.com/Evizero/Augmentor.jl/tree/e49f28df1fb7d0da084ba0aaade9ffe70aa1742b/src/operations/rotation.jl#L156-L210">source</a></section><div><table><tr><th>Input</th><th>Output for <code>Rotate270()</code></th></tr><tr><td><img src="../assets/testpattern.png" alt="input"/></td><td><img src="../assets/Rotate270.png" alt="output"/></td></tr></table></div><hr/><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Augmentor.Rotate" href="#Augmentor.Rotate"><code>Augmentor.Rotate</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">Rotate &lt;: Augmentor.AffineOperation</code></pre><p><strong>Description</strong></p><p>Rotate the image upwards for the given <code>degree</code>. This operation can only be described as an affine transformation and will in general cause other operations of the pipeline to use their affine formulation as well (if they have one).</p><p>In contrast to the special case rotations outlined above, the type <code>Rotate</code> can describe any arbitrary number of degrees. It will always perform the rotation around the center of the image. This can be particularly useful when combining the operation with <a href="#Augmentor.CropNative"><code>CropNative</code></a>.</p><p><strong>Usage</strong></p><pre><code class="language-none">Rotate(degree)</code></pre><p><strong>Arguments</strong></p><ul><li><p><strong><code>degree</code></strong> : <code>Real</code> or <code>AbstractVector</code> of <code>Real</code> that denote   the rotation angle(s) in degree. If a vector is provided,   then a random element will be sampled each time the operation   is applied.</p></li></ul><p><strong>See also</strong></p><p><a href="#Augmentor.Rotate90"><code>Rotate90</code></a>, <a href="#Augmentor.Rotate180"><code>Rotate180</code></a>, <a href="#Augmentor.Rotate270"><code>Rotate270</code></a>, <a href="#Augmentor.CropNative"><code>CropNative</code></a>, <a href="@ref"><code>augment</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia">using Augmentor
img = testpattern()

# rotate exactly 45 degree
augment(img, Rotate(45))

# rotate between 10 and 20 degree upwards
augment(img, Rotate(10:20))

# rotate one of the five specified degrees
augment(img, Rotate([-10, -5, 0, 5, 10]))</code></pre></div><a class="source-link" target="_blank" href="https://github.com/Evizero/Augmentor.jl/tree/e49f28df1fb7d0da084ba0aaade9ffe70aa1742b/src/operations/rotation.jl#L257-L309">source</a></section><p>In contrast to the special case rotations outlined above, the type <code>Rotate</code> can describe any arbitrary number of degrees. It will always perform the rotation around the center of the image. This can be particularly useful when combining the operation with <a href="#Augmentor.CropNative"><code>CropNative</code></a>.</p><div><table><tr><th>Input</th><th>Output for <code>Rotate(15)</code></th></tr><tr><td><img src="../assets/testpattern.png" alt="input"/></td><td><img src="../assets/Rotate.png" alt="output"/></td></tr></table></div><p>It is also possible to pass some abstract vector to the constructor, in which case Augmentor will randomly sample one of its elements every time the operation is applied.</p><div><table><tr><th>Input</th><th>Samples for <code>Rotate(-10:10)</code></th></tr><tr><td><img src="../assets/testpattern.png" alt="input"/></td><td><img src="../assets/Rotate.gif" alt="output"/></td></tr></table></div><h2><a class="nav-anchor" id="Shearing-1" href="#Shearing-1">Shearing</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Augmentor.ShearX" href="#Augmentor.ShearX"><code>Augmentor.ShearX</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">ShearX &lt;: Augmentor.AffineOperation</code></pre><p><strong>Description</strong></p><p>Shear the image horizontally for the given <code>degree</code>. This operation can only be described as an affine transformation and will in general cause other operations of the pipeline to use their affine formulation as well (if they have one).</p><p>It will always perform the transformation around the center of the image. This can be particularly useful when combining the operation with <a href="#Augmentor.CropNative"><code>CropNative</code></a>.</p><p><strong>Usage</strong></p><pre><code class="language-none">ShearX(degree)</code></pre><p><strong>Arguments</strong></p><ul><li><p><strong><code>degree</code></strong> : <code>Real</code> or <code>AbstractVector</code> of <code>Real</code> that denote   the shearing angle(s) in degree. If a vector is provided,   then a random element will be sampled each time the operation   is applied.</p></li></ul><p><strong>See also</strong></p><p><a href="#Augmentor.ShearY"><code>ShearY</code></a>, <a href="#Augmentor.CropNative"><code>CropNative</code></a>, <a href="@ref"><code>augment</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia">using Augmentor
img = testpattern()

# shear horizontally exactly 5 degree
augment(img, ShearX(5))

# shear horizontally between 10 and 20 degree to the right
augment(img, ShearX(10:20))

# shear horizontally one of the five specified degrees
augment(img, ShearX([-10, -5, 0, 5, 10]))</code></pre></div><a class="source-link" target="_blank" href="https://github.com/Evizero/Augmentor.jl/tree/e49f28df1fb7d0da084ba0aaade9ffe70aa1742b/src/operations/shear.jl#L1-L50">source</a></section><p>It will always perform the transformation around the center of the image. This can be particularly useful when combining the operation with <a href="#Augmentor.CropNative"><code>CropNative</code></a>.</p><div><table><tr><th>Input</th><th>Output for <code>ShearX(10)</code></th></tr><tr><td><img src="../assets/testpattern.png" alt="input"/></td><td><img src="../assets/ShearX.png" alt="output"/></td></tr></table></div><p>It is also possible to pass some abstract vector to the constructor, in which case Augmentor will randomly sample one of its elements every time the operation is applied.</p><div><table><tr><th>Input</th><th>Samples for <code>ShearX(-10:10)</code></th></tr><tr><td><img src="../assets/testpattern.png" alt="input"/></td><td><img src="../assets/ShearX.gif" alt="output"/></td></tr></table></div><hr/><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Augmentor.ShearY" href="#Augmentor.ShearY"><code>Augmentor.ShearY</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">ShearY &lt;: Augmentor.AffineOperation</code></pre><p><strong>Description</strong></p><p>Shear the image vertically for the given <code>degree</code>. This operation can only be described as an affine transformation and will in general cause other operations of the pipeline to use their affine formulation as well (if they have one).</p><p>It will always perform the transformation around the center of the image. This can be particularly useful when combining the operation with <a href="#Augmentor.CropNative"><code>CropNative</code></a>.</p><p><strong>Usage</strong></p><pre><code class="language-none">ShearY(degree)</code></pre><p><strong>Arguments</strong></p><ul><li><p><strong><code>degree</code></strong> : <code>Real</code> or <code>AbstractVector</code> of <code>Real</code> that denote   the shearing angle(s) in degree. If a vector is provided,   then a random element will be sampled each time the operation   is applied.</p></li></ul><p><strong>See also</strong></p><p><a href="#Augmentor.ShearX"><code>ShearX</code></a>, <a href="#Augmentor.CropNative"><code>CropNative</code></a>, <a href="@ref"><code>augment</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia">using Augmentor
img = testpattern()

# shear vertically exactly 5 degree
augment(img, ShearY(5))

# shear vertically between 10 and 20 degree upwards
augment(img, ShearY(10:20))

# shear vertically one of the five specified degrees
augment(img, ShearY([-10, -5, 0, 5, 10]))</code></pre></div><a class="source-link" target="_blank" href="https://github.com/Evizero/Augmentor.jl/tree/e49f28df1fb7d0da084ba0aaade9ffe70aa1742b/src/operations/shear.jl#L85-L134">source</a></section><p>It will always perform the transformation around the center of the image. This can be particularly useful when combining the operation with <a href="#Augmentor.CropNative"><code>CropNative</code></a>.</p><div><table><tr><th>Input</th><th>Output for <code>ShearY(10)</code></th></tr><tr><td><img src="../assets/testpattern.png" alt="input"/></td><td><img src="../assets/ShearY.png" alt="output"/></td></tr></table></div><p>It is also possible to pass some abstract vector to the constructor, in which case Augmentor will randomly sample one of its elements every time the operation is applied.</p><div><table><tr><th>Input</th><th>Samples for <code>ShearY(-10:10)</code></th></tr><tr><td><img src="../assets/testpattern.png" alt="input"/></td><td><img src="../assets/ShearY.gif" alt="output"/></td></tr></table></div><h2><a class="nav-anchor" id="Scaling-1" href="#Scaling-1">Scaling</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Augmentor.Scale" href="#Augmentor.Scale"><code>Augmentor.Scale</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">Scale &lt;: Augmentor.AffineOperation</code></pre><p><strong>Description</strong></p><p>Multiplies the image height and image width by the specified <code>factors</code>. This means that the size of the output image depends on the size of the input image.</p><p>The provided <code>factors</code> can either be numbers or vectors of numbers.</p><ul><li><p>If numbers are provided, then the operation is deterministic and will always scale the input image with the same factors.</p></li><li><p>In the case vectors are provided, then each time the operation is applied a valid index is sampled and the elements corresponding to that index are used as scaling factors.</p></li></ul><p>The scaling is performed relative to the image center, which can be useful when following the operation with <a href="#Augmentor.CropNative"><code>CropNative</code></a>.</p><p><strong>Usage</strong></p><pre><code class="language-none">Scale(factors)

Scale(factors...)</code></pre><p><strong>Arguments</strong></p><ul><li><p><strong><code>factors</code></strong> : <code>NTuple</code> or <code>Vararg</code> of <code>Real</code> or   <code>AbstractVector</code> that denote the scale factor(s) for each   array dimension. If only one variable is specified it is   assumed that height and width should be scaled by the same   factor(s).</p></li></ul><p><strong>See also</strong></p><p><a href="#Augmentor.Zoom"><code>Zoom</code></a>, <a href="#Augmentor.Resize"><code>Resize</code></a>, <a href="@ref"><code>augment</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia">using Augmentor
img = testpattern()

# half the image size
augment(img, Scale(0.5))

# uniformly scale by a random factor from 1.2, 1.3, or 1.4
augment(img, Scale([1.2, 1.3, 1.4]))

# scale by either 0.5x0.7 or by 0.6x0.8
augment(img, Scale([0.5, 0.6], [0.7, 0.8]))</code></pre></div><a class="source-link" target="_blank" href="https://github.com/Evizero/Augmentor.jl/tree/e49f28df1fb7d0da084ba0aaade9ffe70aa1742b/src/operations/scale.jl#L1-L61">source</a></section><div><table><tr><th>Input</th><th>Output for <code>Scale(0.9, 0.5)</code></th></tr><tr><td><img src="../assets/testpattern.png" alt="input"/></td><td><img src="../assets/Scale.png" alt="output"/></td></tr></table></div><p>In the case that only a single scale factor is specified, the operation will assume that the intention is to scale all dimensions uniformly by that factor.</p><div><table><tr><th>Input</th><th>Output for <code>Scale(1.2)</code></th></tr><tr><td><img src="../assets/testpattern.png" alt="input"/></td><td><img src="../assets/Scale2.png" alt="output"/></td></tr></table></div><p>It is also possible to pass some abstract vector(s) to the constructor, in which case Augmentor will randomly sample one of its elements every time the operation is applied.</p><div><table><tr><th>Input</th><th>Samples for <code>Scale(0.9:0.05:1.2)</code></th></tr><tr><td><img src="../assets/testpattern.png" alt="input"/></td><td><img src="../assets/Scale.gif" alt="output"/></td></tr></table></div><hr/><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Augmentor.Zoom" href="#Augmentor.Zoom"><code>Augmentor.Zoom</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">Zoom &lt;: Augmentor.ImageOperation</code></pre><p><strong>Description</strong></p><p>Scales the image height and image width by the specified <code>factors</code>, but crops the image such that the original size is preserved.</p><p>The provided <code>factors</code> can either be numbers or vectors of numbers.</p><ul><li><p>If numbers are provided, then the operation is deterministic and will always scale the input image with the same factors.</p></li><li><p>In the case vectors are provided, then each time the operation is applied a valid index is sampled and the elements corresponding to that index are used as scaling factors.</p></li></ul><p>In contrast to <a href="#Augmentor.Scale"><code>Scale</code></a> the size of the output image is the same as the size of the input image, while the content is scaled the same way. The same effect could be achieved by following a <a href="#Augmentor.Scale"><code>Scale</code></a> with a <a href="#Augmentor.CropSize"><code>CropSize</code></a>, with the caveat that one would need to know the exact size of the input image before-hand.</p><p><strong>Usage</strong></p><pre><code class="language-none">Zoom(factors)

Zoom(factors...)</code></pre><p><strong>Arguments</strong></p><ul><li><p><strong><code>factors</code></strong> : <code>NTuple</code> or <code>Vararg</code> of <code>Real</code> or   <code>AbstractVector</code> that denote the scale factor(s) for each   array dimension. If only one variable is specified it is   assumed that height and width should be scaled by the same   factor(s).</p></li></ul><p><strong>See also</strong></p><p><a href="#Augmentor.Scale"><code>Scale</code></a>, <a href="#Augmentor.Resize"><code>Resize</code></a>, <a href="@ref"><code>augment</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia">using Augmentor
img = testpattern()

# half the image size
augment(img, Zoom(0.5))

# uniformly scale by a random factor from 1.2, 1.3, or 1.4
augment(img, Zoom([1.2, 1.3, 1.4]))

# scale by either 0.5x0.7 or by 0.6x0.8
augment(img, Zoom([0.5, 0.6], [0.7, 0.8]))</code></pre></div><a class="source-link" target="_blank" href="https://github.com/Evizero/Augmentor.jl/tree/e49f28df1fb7d0da084ba0aaade9ffe70aa1742b/src/operations/zoom.jl#L1-L65">source</a></section><div><table><tr><th>Input</th><th>Output for <code>Zoom(1.2)</code></th></tr><tr><td><img src="../assets/testpattern.png" alt="input"/></td><td><img src="../assets/Zoom.png" alt="output"/></td></tr></table></div><p>It is also possible to pass some abstract vector to the constructor, in which case Augmentor will randomly sample one of its elements every time the operation is applied.</p><div><table><tr><th>Input</th><th>Samples for <code>Zoom(0.9:0.05:1.3)</code></th></tr><tr><td><img src="../assets/testpattern.png" alt="input"/></td><td><img src="../assets/Zoom.gif" alt="output"/></td></tr></table></div><h2><a class="nav-anchor" id="Resizing-1" href="#Resizing-1">Resizing</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Augmentor.Resize" href="#Augmentor.Resize"><code>Augmentor.Resize</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">Resize &lt;: Augmentor.ImageOperation</code></pre><p><strong>Description</strong></p><p>Transforms the image into a fixed specified pixel size.</p><p>This operation does not take any measures to preserve aspect ratio of the source image. Instead, the original image will simply be resized to the given dimensions. This is useful when one needs a set of images to all be of the exact same size.</p><p><strong>Usage</strong></p><pre><code class="language-none">Resize(; height=64, width=64)

Resize(size)

Resize(size...)</code></pre><p><strong>Arguments</strong></p><ul><li><p><strong><code>size</code></strong> : <code>NTuple</code> or <code>Vararg</code> of <code>Int</code> that denote the   output size in pixel for each dimension.</p></li></ul><p><strong>See also</strong></p><p><a href="#Augmentor.CropSize"><code>CropSize</code></a>, <a href="@ref"><code>augment</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia">using Augmentor
img = testpattern()

augment(img, Resize(30, 40))</code></pre></div><a class="source-link" target="_blank" href="https://github.com/Evizero/Augmentor.jl/tree/e49f28df1fb7d0da084ba0aaade9ffe70aa1742b/src/operations/resize.jl#L1-L43">source</a></section><div><table><tr><th>Input</th><th>Output for <code>Resize(100, 150)</code></th></tr><tr><td><img src="../assets/testpattern.png" alt="input"/></td><td><img src="../assets/Resize.png" alt="output"/></td></tr></table></div><h2><a class="nav-anchor" id="Distorting-1" href="#Distorting-1">Distorting</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Augmentor.ElasticDistortion" href="#Augmentor.ElasticDistortion"><code>Augmentor.ElasticDistortion</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">ElasticDistortion &lt;: Augmentor.ImageOperation</code></pre><p><strong>Description</strong></p><p>Distorts the given image using a randomly (uniform) generated vector field of the given grid size. This field will be stretched over the given image when applied, which in turn will morph the original image into a new image using a linear interpolation of both the image and the vector field.</p><p>In contrast to <a href="@ref"><code>RandomDistortion</code></a>, the resulting vector field is also smoothed using a Gaussian filter with of parameter <code>sigma</code>. This will result in a less chaotic vector field and thus resemble a more natural distortion.</p><p><strong>Usage</strong></p><pre><code class="language-none">ElasticDistortion(gridheight, gridwidth, scale, sigma, [iter=1], [border=false], [norm=true])

ElasticDistortion(gridheight, gridwidth, scale; [sigma=2], [iter=1], [border=false], [norm=true])

ElasticDistortion(gridheight, [gridwidth]; [scale=0.2], [sigma=2], [iter=1], [border=false], [norm=true])</code></pre><p><strong>Arguments</strong></p><ul><li><p><strong><code>gridheight</code></strong> : The grid height of the displacement vector   field. This effectively specifies the number of vertices   along the Y dimension used as landmarks, where all the   positions between the grid points are interpolated.</p></li><li><p><strong><code>gridwidth</code></strong> : The grid width of the displacement vector   field. This effectively specifies the number of vertices   along the Y dimension used as landmarks, where all the   positions between the grid points are interpolated.</p></li><li><p><strong><code>scale</code></strong> : Optional. The scaling factor applied to all   displacement vectors in the field. This effectively defines   the &quot;strength&quot; of the deformation. There is no theoretical   upper limit to this factor, but a value somewhere between   <code>0.01</code> and <code>1.0</code> seem to be the most reasonable choices.   Default to <code>0.2</code>.</p></li><li><p><strong><code>sigma</code></strong> : Optional. Sigma parameter of the Gaussian filter.   This parameter effectively controls the strength of the   smoothing. Defaults to <code>2</code>.</p></li><li><p><strong><code>iter</code></strong> : Optional. The number of times the smoothing   operation is applied to the displacement vector field. This   is especially useful if <code>border = false</code> because the border   will be reset to zero after each pass. Thus the displacement   is a little less aggressive towards the borders of the image   than it is towards its center. Defaults to   <code>1</code>.</p></li><li><p><strong><code>border</code></strong> : Optional. Specifies if the borders should be   distorted as well. If <code>false</code>, the borders of the image will   be preserved. This effectively pins the outermost vertices on   their original position and the operation thus only distorts   the inner content of the image. Defaults to   <code>false</code>.</p></li><li><p><strong><code>norm</code></strong> : Optional. If <code>true</code>, the displacement vectors of   the field will be normalized by the norm of the field. This   will have the effect that the <code>scale</code> factor should be more   or less independent of the grid size. Defaults to   <code>true</code>.</p></li></ul><p><strong>See also</strong></p><p><a href="@ref"><code>RandomDistortion</code></a>, <a href="@ref"><code>augment</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia">using Augmentor
img = testpattern()

# distort with pinned borders
augment(img, ElasticDistortion(15, 15; scale = 0.1))

# distort everything more smoothly.
augment(img, ElasticDistortion(10, 10; sigma = 4, iter=3, border=true))</code></pre></div><a class="source-link" target="_blank" href="https://github.com/Evizero/Augmentor.jl/tree/e49f28df1fb7d0da084ba0aaade9ffe70aa1742b/src/operations/distortion.jl#L7-L96">source</a></section><div><table><tr><th>Input</th><th><code>ElasticDistortion(15, 15, 0.1)</code></th></tr><tr><td><img src="../assets/testpattern.png" alt="input"/></td><td><img src="../assets/ElasticDistortion.gif" alt="output"/></td></tr></table></div><div><table><tr><th>Input</th><th><code>ElasticDistortion(10, 10, 0.2, 4, 3, true)</code></th></tr><tr><td><img src="../assets/testpattern.png" alt="input"/></td><td><img src="../assets/ElasticDistortion2.gif" alt="output"/></td></tr></table></div><h2><a class="nav-anchor" id="Cropping-1" href="#Cropping-1">Cropping</a></h2><p>The process of cropping is useful to discard parts of the input image. To provide this functionality lazily, applying a crop introduces a layer of representation called a &quot;view&quot; or <code>SubArray</code>. This is different yet compatible with how affine operations or other special purpose implementations work. This means that chaining a crop with some affine operation is perfectly fine if done sequentially. However, it is generally not advised to combine affine operations with crop operations within an <a href="#Augmentor.Either"><code>Either</code></a> block. Doing that would force the <a href="#Augmentor.Either"><code>Either</code></a> to trigger the eager computation of its branches in order to preserve type-stability.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Augmentor.Crop" href="#Augmentor.Crop"><code>Augmentor.Crop</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">Crop &lt;: Augmentor.ImageOperation</code></pre><p><strong>Description</strong></p><p>Crops out the area denoted by the specified pixel ranges.</p><p>For example the operation <code>Crop(5:100, 2:10)</code> would denote a crop for the rectangle that starts at <code>x=2</code> and <code>y=5</code> in the top left corner and ends at <code>x=10</code> and <code>y=100</code> in the bottom right corner. As we can see the y-axis is specified first, because that is how the image is stored in an array. Thus the order of the provided indices ranges needs to reflect the order of the array dimensions.</p><p><strong>Usage</strong></p><pre><code class="language-none">Crop(indices)

Crop(indices...)</code></pre><p><strong>Arguments</strong></p><ul><li><p><strong><code>indices</code></strong> : <code>NTuple</code> or <code>Vararg</code> of <code>UnitRange</code> that denote   the cropping range for each array dimension. This is very   similar to how the indices for <code>view</code> are specified.</p></li></ul><p><strong>See also</strong></p><p><a href="#Augmentor.CropNative"><code>CropNative</code></a>, <a href="#Augmentor.CropSize"><code>CropSize</code></a>, <a href="#Augmentor.CropRatio"><code>CropRatio</code></a>, <a href="@ref"><code>augment</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; using Augmentor

julia&gt; img = testpattern()
300×400 Array{RGBA{N0f8},2}:
[...]

julia&gt; augment(img, Crop(1:30, 361:400)) # crop upper right corner
30×40 Array{RGBA{N0f8},2}:
[...]</code></pre></div><a class="source-link" target="_blank" href="https://github.com/Evizero/Augmentor.jl/tree/e49f28df1fb7d0da084ba0aaade9ffe70aa1742b/src/operations/crop.jl#L1-L50">source</a></section><div><table><tr><th>Input</th><th><code>Crop(70:140, 25:155)</code></th></tr><tr><td><img src="../assets/testpattern.png" alt="input"/></td><td><img src="../assets/Crop.png" alt="output"/></td></tr></table></div><hr/><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Augmentor.CropNative" href="#Augmentor.CropNative"><code>Augmentor.CropNative</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">CropNative &lt;: Augmentor.ImageOperation</code></pre><p><strong>Description</strong></p><p>Crops out the area denoted by the specified pixel ranges.</p><p>For example the operation <code>CropNative(5:100, 2:10)</code> would denote a crop for the rectangle that starts at <code>x=2</code> and <code>y=5</code> in the top left corner of native space and ends at <code>x=10</code> and <code>y=100</code> in the bottom right corner of native space.</p><p>In contrast to <a href="#Augmentor.Crop"><code>Crop</code></a>, the position <code>x=1</code> <code>y=1</code> is not necessarily located at the top left of the current image, but instead depends on the cumulative effect of the previous transformations. The reason for this is because affine transformations are usually performed around the center of the image, which is reflected in &quot;native space&quot;. This is useful for combining transformations such as <a href="@ref"><code>Rotation</code></a> or <a href="#Augmentor.ShearX"><code>ShearX</code></a> with a crop around the center area.</p><p><strong>Usage</strong></p><pre><code class="language-none">CropNative(indices)

CropNative(indices...)</code></pre><p><strong>Arguments</strong></p><ul><li><p><strong><code>indices</code></strong> : <code>NTuple</code> or <code>Vararg</code> of <code>UnitRange</code> that denote   the cropping range for each array dimension. This is very   similar to how the indices for <code>view</code> are specified.</p></li></ul><p><strong>See also</strong></p><p><a href="#Augmentor.Crop"><code>Crop</code></a>, <a href="#Augmentor.CropSize"><code>CropSize</code></a>, <a href="#Augmentor.CropRatio"><code>CropRatio</code></a>, <a href="@ref"><code>augment</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia">using Augmentor
img = testpattern()

# cropped at top left corner
augment(img, Rotate(45) |&gt; Crop(1:300, 1:400))

# cropped around center of rotated image
augment(img, Rotate(45) |&gt; CropNative(1:300, 1:400))</code></pre></div><a class="source-link" target="_blank" href="https://github.com/Evizero/Augmentor.jl/tree/e49f28df1fb7d0da084ba0aaade9ffe70aa1742b/src/operations/crop.jl#L91-L145">source</a></section><div><table><tr><th><code>(Rotate(45), Crop(1:210,1:280))</code></th><th><code>(Rotate(45), CropNative(1:210,1:280))</code></th></tr><tr><td><img src="../assets/cropn1.png" alt="input"/></td><td><img src="../assets/cropn2.png" alt="output"/></td></tr></table></div><hr/><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Augmentor.CropSize" href="#Augmentor.CropSize"><code>Augmentor.CropSize</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">CropSize &lt;: Augmentor.ImageOperation</code></pre><p><strong>Description</strong></p><p>Crops out the area of the specified pixel size around the center of the input image.</p><p>For example the operation <code>CropSize(10, 50)</code> would denote a crop for a rectangle of height 10 and width 50 around the center of the input image.</p><p><strong>Usage</strong></p><pre><code class="language-none">CropSize(size)

CropSize(size...)</code></pre><p><strong>Arguments</strong></p><ul><li><p><strong><code>size</code></strong> : <code>NTuple</code> or <code>Vararg</code> of <code>Int</code> that denote the   output size in pixel for each dimension.</p></li></ul><p><strong>See also</strong></p><p><a href="#Augmentor.CropRatio"><code>CropRatio</code></a>, <a href="#Augmentor.Crop"><code>Crop</code></a>, <a href="#Augmentor.CropNative"><code>CropNative</code></a>, <a href="@ref"><code>augment</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia">using Augmentor
img = testpattern()

# cropped around center of rotated image
augment(img, Rotate(45) |&gt; CropSize(300, 400))</code></pre></div><a class="source-link" target="_blank" href="https://github.com/Evizero/Augmentor.jl/tree/e49f28df1fb7d0da084ba0aaade9ffe70aa1742b/src/operations/crop.jl#L190-L231">source</a></section><div><table><tr><th>Input</th><th>Output for <code>CropSize(45, 225)</code></th></tr><tr><td><img src="../assets/testpattern.png" alt="input"/></td><td><img src="../assets/CropSize.png" alt="output"/></td></tr></table></div><hr/><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Augmentor.CropRatio" href="#Augmentor.CropRatio"><code>Augmentor.CropRatio</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">CropRatio &lt;: Augmentor.ImageOperation</code></pre><p><strong>Description</strong></p><p>Crops out the biggest area around the center of the given image such that the output image satisfies the specified aspect ratio (i.e. width divided by height).</p><p>For example the operation <code>CropRatio(1)</code> would denote a crop for the biggest square around the center of the image.</p><p>For randomly placed crops take a look at <a href="#Augmentor.RCropRatio"><code>RCropRatio</code></a>.</p><p><strong>Usage</strong></p><pre><code class="language-none">CropRatio(ratio)

CropRatio(; ratio = 1)</code></pre><p><strong>Arguments</strong></p><ul><li><p><strong><code>ratio::Number</code></strong> : Optional. A number denoting the aspect   ratio. For example specifying <code>ratio=16/9</code> would denote a 16:9   aspect ratio. Defaults to <code>1</code>, which describes a square crop.</p></li></ul><p><strong>See also</strong></p><p><a href="#Augmentor.RCropRatio"><code>RCropRatio</code></a>, <a href="#Augmentor.CropSize"><code>CropSize</code></a>, <a href="#Augmentor.Crop"><code>Crop</code></a>, <a href="#Augmentor.CropNative"><code>CropNative</code></a>, <a href="@ref"><code>augment</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia">using Augmentor
img = testpattern()

# crop biggest square around the image center
augment(img, CropRatio(1))</code></pre></div><a class="source-link" target="_blank" href="https://github.com/Evizero/Augmentor.jl/tree/e49f28df1fb7d0da084ba0aaade9ffe70aa1742b/src/operations/crop.jl#L287-L331">source</a></section><div><table><tr><th>Input</th><th>Output for <code>CropRatio(1)</code></th></tr><tr><td><img src="../assets/testpattern.png" alt="input"/></td><td><img src="../assets/CropRatio.png" alt="output"/></td></tr></table></div><hr/><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Augmentor.RCropRatio" href="#Augmentor.RCropRatio"><code>Augmentor.RCropRatio</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">RCropRatio &lt;: Augmentor.ImageOperation</code></pre><p><strong>Description</strong></p><p>Crops out the biggest possible area at some random position of the given image, such that the output image satisfies the specified aspect ratio (i.e. width divided by height).</p><p>For example the operation <code>RCropRatio(1)</code> would denote a crop for the biggest possible square. If there is more than one such square, then one will be selected at random.</p><p><strong>Usage</strong></p><pre><code class="language-none">RCropRatio(ratio)

RCropRatio(; ratio = 1)</code></pre><p><strong>Arguments</strong></p><ul><li><p><strong><code>ratio::Number</code></strong> : Optional. A number denoting the aspect   ratio. For example specifying <code>ratio=16/9</code> would denote a 16:9   aspect ratio. Defaults to <code>1</code>, which describes a square crop.</p></li></ul><p><strong>See also</strong></p><p><a href="#Augmentor.CropRatio"><code>CropRatio</code></a>, <a href="#Augmentor.CropSize"><code>CropSize</code></a>, <a href="#Augmentor.Crop"><code>Crop</code></a>, <a href="#Augmentor.CropNative"><code>CropNative</code></a>, <a href="@ref"><code>augment</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia">using Augmentor
img = testpattern()

# crop a randomly placed square of maxmimum size
augment(img, RCropRatio(1))</code></pre></div><a class="source-link" target="_blank" href="https://github.com/Evizero/Augmentor.jl/tree/e49f28df1fb7d0da084ba0aaade9ffe70aa1742b/src/operations/crop.jl#L410-L453">source</a></section><div><table><tr><th>Input</th><th>Samples for <code>RCropRatio(1)</code></th></tr><tr><td><img src="../assets/testpattern.png" alt="input"/></td><td><img src="../assets/RCropRatio.gif" alt="output"/></td></tr></table></div><h2><a class="nav-anchor" id="Conversion-1" href="#Conversion-1">Conversion</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Augmentor.ConvertEltype" href="#Augmentor.ConvertEltype"><code>Augmentor.ConvertEltype</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">ConvertEltype &lt;: Augmentor.Operation</code></pre><p><strong>Description</strong></p><p>Convert the element type of the given array/image into the given <code>eltype</code>. This operation is especially useful for converting color images to grayscale (or the other way around). That said the operation is not specific to color types and can also be used for numeric arrays (e.g. with separated channels).</p><p>Note that this is an element-wise convert function. Thus it can not be used to combine or separate color channels. Use <a href="#Augmentor.SplitChannels"><code>SplitChannels</code></a> or <a href="#Augmentor.CombineChannels"><code>CombineChannels</code></a> for those purposes.</p><p><strong>Usage</strong></p><pre><code class="language-none">ConvertEltype(eltype)</code></pre><p><strong>Arguments</strong></p><ul><li><p><strong><code>eltype</code></strong> : The eltype of the resulting array/image.</p></li></ul><p><strong>See also</strong></p><p><a href="#Augmentor.CombineChannels"><code>CombineChannels</code></a>, <a href="#Augmentor.SplitChannels"><code>SplitChannels</code></a>, <a href="@ref"><code>augment</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; using Augmentor, Colors

julia&gt; A = rand(RGB, 10, 10) # three color channels
10×10 Array{RGB{Float64},2}:
[...]

julia&gt; augment(A, ConvertEltype(Gray)) # convert to grayscale
10×10 Array{Gray{Float64},2}:
[...]

julia&gt; augment(A, ConvertEltype(Gray{Float32})) # more specific
10×10 Array{Gray{Float32},2}:
[...]</code></pre></div><a class="source-link" target="_blank" href="https://github.com/Evizero/Augmentor.jl/tree/e49f28df1fb7d0da084ba0aaade9ffe70aa1742b/src/operations/convert.jl#L1-L51">source</a></section><div><table><tr><th>Input</th><th><code>ConvertEltype(GrayA)</code></th></tr><tr><td><img src="../assets/testpattern.png" alt="input"/></td><td><img src="../assets/ConvertEltype.png" alt="output"/></td></tr></table></div><h2><a class="nav-anchor" id="Color-Channels-1" href="#Color-Channels-1">Color Channels</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Augmentor.SplitChannels" href="#Augmentor.SplitChannels"><code>Augmentor.SplitChannels</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">SplitChannels &lt;: Augmentor.Operation</code></pre><p><strong>Description</strong></p><p>Splits out the color channels of the given image using the function <code>ImageCore.channelview</code>. This will effectively create a new array dimension for the colors in the front. In contrast to <code>ImageCore.channelview</code> it will also result in a new dimension for Gray images.</p><p>This operation is mainly useful at the end of a pipeline in combination with <a href="#Augmentor.PermuteDims"><code>PermuteDims</code></a> in order to prepare the image for the training algorithm, which often requires the color channels to be separate.</p><p><strong>Usage</strong></p><pre><code class="language-none">SplitChannels()</code></pre><p><strong>See also</strong></p><p><a href="#Augmentor.PermuteDims"><code>PermuteDims</code></a>, <a href="#Augmentor.CombineChannels"><code>CombineChannels</code></a>, <a href="@ref"><code>augment</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; using Augmentor

julia&gt; img = testpattern()
300×400 Array{RGBA{N0f8},2}:
[...]

julia&gt; augment(img, SplitChannels())
4×300×400 Array{N0f8,3}:
[...]

julia&gt; augment(img, SplitChannels() |&gt; PermuteDims(3,2,1))
400×300×4 Array{N0f8,3}:
[...]</code></pre></div><a class="source-link" target="_blank" href="https://github.com/Evizero/Augmentor.jl/tree/e49f28df1fb7d0da084ba0aaade9ffe70aa1742b/src/operations/channels.jl#L1-L46">source</a></section><hr/><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Augmentor.CombineChannels" href="#Augmentor.CombineChannels"><code>Augmentor.CombineChannels</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">CombineChannels &lt;: Augmentor.Operation</code></pre><p><strong>Description</strong></p><p>Combines the first dimension of a given array into a colorant of type <code>colortype</code> using the function <code>ImageCore.colorview</code>. The main difference is that a separate color channel is also expected for Gray images.</p><p>The shape of the input image has to be appropriate for the given <code>colortype</code>, which also means that the separated color channel has to be the first dimension of the array. See <a href="#Augmentor.PermuteDims"><code>PermuteDims</code></a> if that is not the case.</p><p><strong>Usage</strong></p><pre><code class="language-none">CombineChannels(colortype)</code></pre><p><strong>Arguments</strong></p><ul><li><p><strong><code>colortype</code></strong> : The color type of the resulting image. Must   be a subtype of <code>ColorTypes.Colorant</code> and match the color   channel of the given image.</p></li></ul><p><strong>See also</strong></p><p><a href="#Augmentor.SplitChannels"><code>SplitChannels</code></a>, <a href="#Augmentor.PermuteDims"><code>PermuteDims</code></a>, <a href="@ref"><code>augment</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; using Augmentor, Colors

julia&gt; A = rand(3, 10, 10) # three color channels
3×10×10 Array{Float64,3}:
[...]

julia&gt; augment(A, CombineChannels(RGB))
10×10 Array{RGB{Float64},2}:
[...]

julia&gt; B = rand(1, 10, 10) # singleton color channel
1×10×10 Array{Float64,3}:
[...]

julia&gt; augment(B, CombineChannels(Gray))
10×10 Array{Gray{Float64},2}:
[...]</code></pre></div><a class="source-link" target="_blank" href="https://github.com/Evizero/Augmentor.jl/tree/e49f28df1fb7d0da084ba0aaade9ffe70aa1742b/src/operations/channels.jl#L73-L128">source</a></section><h2><a class="nav-anchor" id="Array-Shape-1" href="#Array-Shape-1">Array Shape</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Augmentor.PermuteDims" href="#Augmentor.PermuteDims"><code>Augmentor.PermuteDims</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">PermuteDims &lt;: Augmentor.Operation</code></pre><p><strong>Description</strong></p><p>Permute the dimensions of the given array with the predefined permutation <code>perm</code>. This operation is particularly useful if the order of the dimensions needs to be different than the default julian layout.</p><p>Augmentor expects the given images to be in vertical-major layout for which the colors are encoded in the element type itself. Many deep learning frameworks however require their input in a different order. For example it is not untypical that the color channels are expected to be encoded in the third dimension.</p><p><strong>Usage</strong></p><pre><code class="language-none">PermuteDims(perm)

PermuteDims(perm...)</code></pre><p><strong>Arguments</strong></p><ul><li><p><strong><code>perm</code></strong> : The concrete dimension permutation that should be   used. Has to be specified as a <code>Vararg{Int}</code> or as a <code>NTuple</code>   of <code>Int</code>. The length of <code>perm</code> has to match the number of   dimensions of the expected input image to that operation.</p></li></ul><p><strong>See also</strong></p><p><a href="#Augmentor.SplitChannels"><code>SplitChannels</code></a>, <a href="#Augmentor.CombineChannels"><code>CombineChannels</code></a>, <a href="@ref"><code>augment</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; using Augmentor, Colors

julia&gt; A = rand(10, 5, 3) # width=10, height=5, and 3 color channels
10×5×3 Array{Float64,3}:
[...]

julia&gt; img = augment(A, PermuteDims(3,2,1) |&gt; CombineChannels(RGB))
5×10 Array{RGB{Float64},2}:
[...]

julia&gt; img2 = testpattern()
300×400 Array{RGBA{N0f8},2}:
[...]

julia&gt; B = augment(img2, SplitChannels() |&gt; PermuteDims(3,2,1))
400×300×4 Array{N0f8,3}:
[...]</code></pre></div><a class="source-link" target="_blank" href="https://github.com/Evizero/Augmentor.jl/tree/e49f28df1fb7d0da084ba0aaade9ffe70aa1742b/src/operations/channels.jl#L164-L223">source</a></section><hr/><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Augmentor.Reshape" href="#Augmentor.Reshape"><code>Augmentor.Reshape</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">Reshape &lt;: Augmentor.Operation</code></pre><p><strong>Description</strong></p><p>Reinterpret the shape of the given array of numbers or colorants. This is useful for example to create singleton dimensions that deep learning frameworks may need for colorless images, or for converting an image to a feature vector and vice versa.</p><p><strong>Usage</strong></p><pre><code class="language-none">Reshape(dims)

Reshape(dims...)</code></pre><p><strong>Arguments</strong></p><ul><li><p><strong><code>dims</code></strong> : The new sizes for each dimension of the output   image. Has to be specified as a <code>Vararg{Int}</code> or as a   <code>NTuple</code> of <code>Int</code>.</p></li></ul><p><strong>See also</strong></p><p><a href="#Augmentor.CombineChannels"><code>CombineChannels</code></a>, <a href="@ref"><code>augment</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; using Augmentor, Colors

julia&gt; A = rand(10,10)
10×10 Array{Float64,2}:
[...]

julia&gt; augment(A, Reshape(10,10,1)) # add trailing singleton dimension
10×10×1 Array{Float64,3}:
[...]</code></pre></div><a class="source-link" target="_blank" href="https://github.com/Evizero/Augmentor.jl/tree/e49f28df1fb7d0da084ba0aaade9ffe70aa1742b/src/operations/channels.jl#L255-L299">source</a></section><h2><a class="nav-anchor" id="Utility-Operations-1" href="#Utility-Operations-1">Utility Operations</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Augmentor.CacheImage" href="#Augmentor.CacheImage"><code>Augmentor.CacheImage</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">CacheImage &lt;: Augmentor.ImageOperation</code></pre><p><strong>Description</strong></p><p>Write the current state of the image into the working memory. Optionally a user has the option to specify a preallocated <code>buffer</code> to write the image into. Note that if a <code>buffer</code> is provided, then it has to be of the correct size and eltype.</p><p>Even without a preallocated <code>buffer</code> it can be beneficial in some situations to cache the image. An example for such a scenario is when chaining a number of affine transformations after an elastic distortion, because performing that lazily requires nested interpolation.</p><p><strong>Usage</strong></p><pre><code class="language-none">CacheImage()

CacheImage(buffer)</code></pre><p><strong>Arguments</strong></p><ul><li><p><strong><code>buffer</code></strong> : Optional. A preallocated <code>AbstractArray</code> of the   appropriate size and eltype.</p></li></ul><p><strong>See also</strong></p><p><a href="@ref"><code>augment</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia">using Augmentor

# make pipeline that forces caching after elastic distortion
pl = ElasticDistortion(3,3) |&gt; CacheImage() |&gt; Rotate(-10:10) |&gt; ShearX(-5:5)

# cache output of elastic distortion into the allocated
# 20x20 Matrix{Float64}. Note that for this case this assumes that
# the input image is also a 20x20 Matrix{Float64}
pl = ElasticDistortion(3,3) |&gt; CacheImage(zeros(20,20)) |&gt; Rotate(-10:10)

# convenience syntax with the same effect as above.
pl = ElasticDistortion(3,3) |&gt; zeros(20,20) |&gt; Rotate(-10:10)</code></pre></div><a class="source-link" target="_blank" href="https://github.com/Evizero/Augmentor.jl/tree/e49f28df1fb7d0da084ba0aaade9ffe70aa1742b/src/operations/cache.jl#L1-L53">source</a></section><hr/><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Augmentor.NoOp" href="#Augmentor.NoOp"><code>Augmentor.NoOp</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">NoOp &lt;: Augmentor.AffineOperation</code></pre><p>Identity transformation that does not do anything with the given image but instead passes it along unchanged (without copying).</p><p>Usually used in combination with <a href="#Augmentor.Either"><code>Either</code></a> to denote a &quot;branch&quot; that does not perform any computation.</p></div><a class="source-link" target="_blank" href="https://github.com/Evizero/Augmentor.jl/tree/e49f28df1fb7d0da084ba0aaade9ffe70aa1742b/src/operations/noop.jl#L1-L9">source</a></section><hr/><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Augmentor.Either" href="#Augmentor.Either"><code>Augmentor.Either</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">Either &lt;: Augmentor.ImageOperation</code></pre><p><strong>Description</strong></p><p>Allows for choosing between different <code>Augmentor.Operations</code> at random when applied. This is particularly useful if one for example wants to first either rotate the image 90 degree clockwise or anticlockwise (but never both) and then apply some other operation(s) afterwards.</p><p>When compiling a pipeline, <code>Either</code> will analyze the provided <code>operations</code> in order to identify the most preferred way to apply the individual operation when sampled, that is supported by all given <code>operations</code>. This way the output of applying <code>Either</code> will be inferable and the whole pipeline will remain type-stable, even though randomness is involved.</p><p>By default each specified image operation has the same probability of occurrence. This default behaviour can be overwritten by specifying the <code>chance</code> manually.</p><p><strong>Usage</strong></p><pre><code class="language-none">Either(operations, [chances])

Either(operations...; [chances])

Either(pairs...)

*(operations...)

*(pairs...)</code></pre><p><strong>Arguments</strong></p><ul><li><p><strong><code>operations</code></strong> : <code>NTuple</code> or <code>Vararg</code> of <code>Augmentor.ImageOperation</code>   that denote the possible choices to sample from when applied.</p></li><li><p><strong><code>chances</code></strong> : Optional. Denotes the relative chances for an   operation to be sampled. Has to contain the same number of   elements as <code>operations</code>. Either an <code>NTuple</code> of numbers if   specified as positional argument, or alternatively a   <code>AbstractVector</code> of numbers if specified as a keyword   argument. If omitted every operation will have equal   probability of occurring.</p></li><li><p><strong><code>pairs</code></strong> : <code>Vararg</code> of <code>Pair{&lt;:Real,&lt;:Augmentor.ImageOperation}</code>.   A compact way to specify an operation and its chance of   occurring together.</p></li></ul><p><strong>See also</strong></p><p><a href="#Augmentor.NoOp"><code>NoOp</code></a>, <a href="@ref"><code>augment</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia">using Augmentor
img = testpattern()

# all three operations have equal chance of occuring
augment(img, Either(FlipX(), FlipY(), NoOp()))
augment(img, FlipX() * FlipY() * NoOp())

# NoOp is twice as likely as either FlipX or FlipY
augment(img, Either(1=&gt;FlipX(), 1=&gt;FlipY(), 2=&gt;NoOp()))
augment(img, Either(FlipX(), FlipY(), NoOp(), chances=[1,1,2]))
augment(img, Either((FlipX(), FlipY(), NoOp()), (1,1,2)))
augment(img, (1=&gt;FlipX()) * (1=&gt;FlipY()) * (2=&gt;NoOp()))</code></pre></div><a class="source-link" target="_blank" href="https://github.com/Evizero/Augmentor.jl/tree/e49f28df1fb7d0da084ba0aaade9ffe70aa1742b/src/operations/either.jl#L1-L77">source</a></section><footer><hr/><a class="previous" href="../images/"><span class="direction">Previous</span><span class="title">Working with Images in Julia</span></a><a class="next" href="../generated/testexample/"><span class="direction">Next</span><span class="title">Test Tutorial</span></a></footer></article></body></html>
